<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LifeDex</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<style>
body{
  margin:0;
  background:radial-gradient(#0b1220,#05080f);
  font-family:system-ui,-apple-system;
  color:white;
}
#root{max-width:420px;margin:auto;padding:18px}
h1{margin:0;font-size:28px}
h2{margin:0 0 6px 0}
.muted{color:#9ca3af;font-size:13px}

.card{
  background:linear-gradient(180deg,#111827,#05080f);
  border-radius:18px;
  padding:14px;
  margin:12px 0;
  border:1px solid rgba(255,255,255,0.08)
}
.banner{
  border-radius:14px;
  padding:10px;
  margin-bottom:8px;
  position:relative;
}

.bar{height:10px;border-radius:999px;background:#222;overflow:hidden}
.fill{
  height:100%;
  background:linear-gradient(90deg,#22c55e,#38bdf8);
  transition: width .52s cubic-bezier(.15,.85,.2,1.12);
  transform-origin:left center;
}
.fill.bump{
  animation: barBump .42s cubic-bezier(.2,.9,.2,1);
}
@keyframes barBump{
  0%{transform:scaleY(1)}
  45%{transform:scaleY(1.35)}
  100%{transform:scaleY(1)}
}

button{
  padding:10px 14px;
  border-radius:14px;
  border:none;
  font-weight:700;
  cursor:pointer;
  transition: transform .08s ease, filter .08s ease;
}
button:hover{filter:brightness(1.06)}
button:active{transform:scale(.965)}
.btn{background:#fbbf24;color:#0b1220}
.btn2{background:#1f2937;color:white}
.btnDanger{background:#7f1d1d;color:white}
.row{display:flex;gap:8px;flex-wrap:wrap}

textarea,input,select{
  width:100%;
  padding:10px;
  border-radius:10px;
  border:none;
  margin-top:8px;
  background:rgba(255,255,255,.06);
  color:white;
  outline:none;
}
textarea{resize:vertical; min-height:90px}

.back{
  width:100%;
  background:linear-gradient(90deg,#fbbf24,#fb923c);
  color:black;
  margin-bottom:12px
}

.pillRow{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap}
.pill{
  padding:6px 10px;border-radius:999px;background:#111;color:white;
  font-size:12px;cursor:pointer;border:1px solid rgba(255,255,255,.08);
  user-select:none;
}
.pill.active{background:#fbbf24;color:black}

.logItem{
  border-radius:14px;
  padding:10px;
  margin:8px 0;
  border:1px solid rgba(255,255,255,.08);
  background:rgba(255,255,255,.04)
}

.skill { background: linear-gradient(90deg,#16a34a33,#22c55e22); }
.career { background: linear-gradient(90deg,#2563eb33,#38bdf822); }
.trait { background: linear-gradient(90deg,#7c3aed33,#a78bfa22); }
.hobby { background: linear-gradient(90deg,#ea580c33,#fb923c22); }

.smallNote{font-size:12px;color:#9ca3af;margin-top:8px}
hr.sep{border:none;border-top:1px solid rgba(255,255,255,.08); margin:12px 0}

/* -------- Phase 1 FX -------- */
@keyframes xpFloat {
  0%   { opacity:0; transform:translateY(6px) scale(.98); }
  10%  { opacity:1; transform:translateY(0) scale(1); }
  100% { opacity:0; transform:translateY(-22px) scale(1.02); }
}
.xpFloat{
  position:absolute;
  right:10px;
  top:8px;
  font-weight:800;
  font-size:12px;
  letter-spacing:.2px;
  pointer-events:none;
  text-shadow: 0 2px 10px rgba(0,0,0,.5);
  animation: xpFloat .70s ease-out forwards;
}

@keyframes levelGlow {
  0%{ box-shadow:0 0 0 rgba(251,191,36,0); }
  45%{ box-shadow:0 0 18px rgba(251,191,36,.55); }
  100%{ box-shadow:0 0 0 rgba(251,191,36,0); }
}
.levelUpGlow{
  animation: levelGlow .80s ease;
}

@keyframes savePulse {
  0%{ box-shadow:0 0 0 rgba(34,197,94,0); }
  50%{ box-shadow:0 0 16px rgba(34,197,94,.32); }
  100%{ box-shadow:0 0 0 rgba(34,197,94,0); }
}
.savePulse{
  animation: savePulse .60s ease;
}

/* -------- Phase 2: visibility -------- */
.todayLine{
  margin-top:6px;
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:center;
}
.todayPill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.04);
  font-size:12px;
  color:#e5e7eb;
}

@keyframes recentGoldIn {
  0%{ box-shadow: 0 0 0 rgba(251,191,36,0); border-color: rgba(255,255,255,.08); }
  100%{ box-shadow: 0 0 18px rgba(251,191,36,.22); border-color: rgba(251,191,36,.28); }
}
.recentGlow{
  box-shadow: 0 0 18px rgba(251,191,36,.22);
  border-color: rgba(251,191,36,.28);
  animation: recentGoldIn .45s ease-out;
}

/* -------- Phase 3: streak + toasts (minimal) -------- */
.toastWrap{
  position:fixed;
  top:12px;
  right:12px;
  z-index:9999;
  display:flex;
  flex-direction:column;
  gap:8px;
  pointer-events:none;
}
.toast{
  pointer-events:none;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(17,24,39,.92);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  font-size:13px;
  color:#f9fafb;
  max-width:260px;
  animation: toastIn .18s ease-out, toastOut .35s ease-in forwards;
  animation-delay: 0s, 1.35s;
}
@keyframes toastIn{
  from{ opacity:0; transform:translateY(-6px) scale(.98); }
  to{ opacity:1; transform:translateY(0) scale(1); }
}
@keyframes toastOut{
  to{ opacity:0; transform:translateY(-4px) scale(.985); }
}
.streakPill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.04);
  font-size:12px;
  color:#e5e7eb;
}

</style>
</head>

<body>
<div id="root"></div>

<script>
// @ts-nocheck
const LEVELS = ["Beginner", "Practitioner", "Advanced", "Expert", "Master"];
const XP_STEP = 100;
const MAX_HISTORY = 30;
const MAX_TIMELINE = 300;
// --- HARDENING PASS (versioned storage) ---
const STORAGE_KEY = "lifedex_v2";
const SCHEMA_VERSION = 3;
const DEV = false;
// --- Sound scaffold (disabled for now; ready later) ---
const Sound = {
    enabled: false,
    play(name) {
        if (!this.enabled)
            return;
    }
};
function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
function safeUUID() {
    if (typeof crypto !== "undefined" && crypto.randomUUID)
        return crypto.randomUUID();
    return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function assertSoft(cond, msg) { if (!cond && DEV)
    console.warn("[LifeDex]", msg); }
function safeNumber(n, fallback = 0) {
    const v = Number(n);
    return Number.isFinite(v) ? v : fallback;
}
function safeString(s, fallback = "") {
    if (s === null || s === undefined)
        return fallback;
    return String(s);
}
function validDexType(t) { return ["Skill", "Career", "Trait", "Hobby"].includes(t); }
function validEntryType(t) { return safeString(t || "note", "note"); }
function dexTypeColor(type) {
    switch (type) {
        case "Skill": return "#22c55e";
        case "Career": return "#38bdf8";
        case "Trait": return "#a78bfa";
        case "Hobby": return "#fb923c";
        default: return "#fbbf24";
    }
}
function defaultSeed() {
    return {
        version: SCHEMA_VERSION,
        dexes: [
            { id: safeUUID(), name: "LifeDoc", type: "Skill", xp: 95, log: [] },
            { id: safeUUID(), name: "BlueCollar Trades", type: "Career", xp: 20, log: [] },
            { id: safeUUID(), name: "Reliability", type: "Trait", xp: 40, log: [] },
            { id: safeUUID(), name: "Artistry", type: "Hobby", xp: 5, log: [] }
        ],
        timeline: []
    };
}
function repairState(raw) {
    const out = {
        version: safeNumber(raw === null || raw === void 0 ? void 0 : raw.version, SCHEMA_VERSION),
        dexes: Array.isArray(raw === null || raw === void 0 ? void 0 : raw.dexes) ? raw.dexes : [],
        timeline: Array.isArray(raw === null || raw === void 0 ? void 0 : raw.timeline) ? raw.timeline : []
    };
    const seen = new Set();
    out.dexes = out.dexes.map(d => {
        let id = safeString(d === null || d === void 0 ? void 0 : d.id, "");
        if (!id || seen.has(id))
            id = safeUUID();
        seen.add(id);
        const name = safeString(d === null || d === void 0 ? void 0 : d.name, "Untitled").trim() || "Untitled";
        const type = validDexType(d === null || d === void 0 ? void 0 : d.type) ? d.type : "Skill";
        const xp = Math.max(0, safeNumber(d === null || d === void 0 ? void 0 : d.xp, 0));
        const log = Array.isArray(d === null || d === void 0 ? void 0 : d.log) ? d.log : [];
        const fixedLog = log.map(e => ({
            text: safeString(e === null || e === void 0 ? void 0 : e.text, "").trim(),
            xp: safeNumber(e === null || e === void 0 ? void 0 : e.xp, 0),
            entryType: validEntryType((e === null || e === void 0 ? void 0 : e.entryType) || (e === null || e === void 0 ? void 0 : e.type) || "note"),
            ts: safeNumber(e === null || e === void 0 ? void 0 : e.ts, Date.now())
        })).filter(e => e.text.length || e.xp !== 0);
        return { id, name, type, xp, log: fixedLog };
    });
    out.timeline = out.timeline.map(t => {
        var _a;
        return ({
            dexId: (_a = t === null || t === void 0 ? void 0 : t.dexId) !== null && _a !== void 0 ? _a : null,
            dex: safeString(t === null || t === void 0 ? void 0 : t.dex, ""),
            dexType: validDexType(t === null || t === void 0 ? void 0 : t.dexType) ? t.dexType : "Skill",
            entryType: validEntryType((t === null || t === void 0 ? void 0 : t.entryType) || (t === null || t === void 0 ? void 0 : t.kind) || "note"),
            xp: safeNumber(t === null || t === void 0 ? void 0 : t.xp, 0),
            text: safeString(t === null || t === void 0 ? void 0 : t.text, "").trim(),
            ts: safeNumber(t === null || t === void 0 ? void 0 : t.ts, Date.now())
        });
    }).filter(t => t.text.length || t.xp !== 0);
    out.timeline = out.timeline.slice(0, MAX_TIMELINE);
    assertSoft(out.dexes.every(d => d.id && d.name && validDexType(d.type)), "Dex repair triggered.");
    assertSoft(out.timeline.length <= MAX_TIMELINE, "Timeline capped.");
    return out;
}
function migrateState(loaded) {
    if (!loaded || typeof loaded !== "object")
        return null;
    if (loaded.version === undefined) {
        const repaired = repairState({ version: SCHEMA_VERSION, dexes: loaded.dexes, timeline: loaded.timeline });
        repaired.version = SCHEMA_VERSION;
        return repaired;
    }
    const v = safeNumber(loaded.version, SCHEMA_VERSION);
    const repaired = repairState(loaded);
    repaired.version = v;
    return repaired;
}
function loadState() {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw)
            return null;
        const parsed = JSON.parse(raw);
        return migrateState(parsed);
    }
    catch (e) {
        if (DEV)
            console.warn("[LifeDex] Failed to load state:", e);
        return null;
    }
}
function saveState(payload) {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        return true;
    }
    catch (e) {
        if (DEV)
            console.warn("[LifeDex] Failed to save state:", e);
        return false;
    }
}
// --- Export / Import ---
function downloadJSON(filename, obj) {
    try {
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }
    catch (e) {
        alert("Export failed.");
    }
}
function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(String(r.result || ""));
        r.onerror = () => reject(new Error("File read failed"));
        r.readAsText(file);
    });
}
// --- Level math ---
function levelIndexFromXP(xp) {
    return clamp(Math.floor((xp || 0) / XP_STEP), 0, LEVELS.length - 1);
}
function levelFromXP(xp) { return LEVELS[levelIndexFromXP(xp)]; }
function progressPercent(xp) {
    const v = ((xp || 0) % XP_STEP + XP_STEP) % XP_STEP;
    return (v / XP_STEP) * 100;
}
function xpToNextLevelInfo(xp) {
    const idx = levelIndexFromXP(xp);
    if (idx >= LEVELS.length - 1) {
        return { done: true, label: "Max level" };
    }
    const remRaw = XP_STEP - (((xp || 0) % XP_STEP + XP_STEP) % XP_STEP);
    const rem = remRaw === 0 ? XP_STEP : remRaw;
    const next = LEVELS[idx + 1];
    return { done: false, remaining: rem, next };
}
// --- Today XP ---
function startOfLocalDayTs() {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    return d.getTime();
}
function computeTodayXP(timeline) {
    const start = startOfLocalDayTs();
    const end = start + 86400000;
    let sum = 0;
    for (const t of timeline) {
        const ts = safeNumber(t === null || t === void 0 ? void 0 : t.ts, 0);
        if (ts >= start && ts < end) {
            sum += safeNumber(t === null || t === void 0 ? void 0 : t.xp, 0);
        }
    }
    return sum;
}

// --- Streak (recalculated; timeline-based, plus in-session activity today) ---
function localDayKey(ts){
  const d = new Date(ts);
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
}
function computeStreakDaysFromDaySet(daySet){
  const todayKey = localDayKey(Date.now());
  if (!daySet.has(todayKey)) return 0;
  let streak = 0;
  const cursor = new Date();
  cursor.setHours(0,0,0,0);
  while(true){
    const key = localDayKey(cursor.getTime());
    if (!daySet.has(key)) break;
    streak += 1;
    cursor.setDate(cursor.getDate()-1);
  }
  return streak;
}
function daySetFromTimeline(timeline){
  const days = new Set();
  for (const t of timeline){
    const ts = safeNumber(t?.ts, 0);
    if (!ts) continue;
    const xp = safeNumber(t?.xp, 0);
    const text = safeString(t?.text, "").trim();
    if (xp === 0 && !text) continue;
    days.add(localDayKey(ts));
  }
  return days;
}
function totalXPFromDexes(dexes){
  let sum = 0;
  for (const d of dexes) sum += Math.max(0, safeNumber(d?.xp, 0));
  return sum;
}

// ---- FX component ----
function ToastLayer({ toasts }) {
  return React.createElement("div", { className: "toastWrap" }, (toasts||[]).map(t => React.createElement("div", { key: t.id, className: "toast" }, t.text)));
}

function XPFloat({ delta, color, nonce }) {
    return (React.createElement("div", { key: nonce, className: "xpFloat", style: { color } },
        delta > 0 ? `+${delta}` : `${delta}`,
        " XP"));
}
function App() {
    const [screen, setScreen] = React.useState("home"); // home|details|journal|timeline|dexForm
    const [active, setActive] = React.useState(null);
    const [filter, setFilter] = React.useState("All");
    const [journal, setJournal] = React.useState("");
    // Dex form state
    const [formMode, setFormMode] = React.useState("create"); // create|edit
    const [formId, setFormId] = React.useState(null);
    const [formName, setFormName] = React.useState("");
    const [formType, setFormType] = React.useState("Skill");
    // Import control
    const importRef = React.useRef(null);
    // ---- Phase 1 FX state (NOT persisted) ----
    const [xpFx, setXpFx] = React.useState({ dexId: null, delta: 0, color: "#fff", nonce: 0 });
    const [lvlFx, setLvlFx] = React.useState({ dexId: null, nonce: 0 });
    const [bumpFx, setBumpFx] = React.useState({ dexId: null, nonce: 0 });
    const [pulseFx, setPulseFx] = React.useState({ capture: 0, journal: 0 });
    // ---- Phase 2: recent highlight (NOT persisted) ----
    const [recentMap, setRecentMap] = React.useState({}); // dexId -> true
    const recentTimers = React.useRef({}); // dexId -> timeoutId

    // ---- Phase 3: toasts + in-session activity (NOT persisted) ----
    const [toasts, setToasts] = React.useState([]);
    const [sessionTodayXP, setSessionTodayXP] = React.useState(0);
    const sessionDayRef = React.useRef(localDayKey(Date.now()));
    const prevTotalRef = React.useRef(null);
    const prevLevelsRef = React.useRef({}); // dexId -> levelIndex
    const lastToastRef = React.useRef({}); // simple de-dupe


    React.useEffect(() => {
        return () => {
            const timers = recentTimers.current;
            for (const k in timers) {
                try { clearTimeout(timers[k]); } catch (e) {}
            }
        };
    }, []);

    function isRecent(dexId) {
        return !!recentMap[dexId];
    }

    function markRecent(dexId) {
        const timers = recentTimers.current;
        if (timers[dexId]) {
            try { clearTimeout(timers[dexId]); } catch (e) {}
        }
        // Mark immediately (UI highlight)
        setRecentMap(prev => ({ ...prev, [dexId]: true }));
        // Auto-clear after 10s without any polling/re-render loops
        timers[dexId] = setTimeout(() => {
            setRecentMap(prev => {
                if (!prev[dexId]) return prev;
                const next = { ...prev };
                delete next[dexId];
                return next;
            });
            delete timers[dexId];
        }, 10000);
    }

    function clearRecent(dexId) {
        const timers = recentTimers.current;
        if (timers[dexId]) {
            try { clearTimeout(timers[dexId]); } catch (e) {}
            delete timers[dexId];
        }
        setRecentMap(prev => {
            if (!prev[dexId]) return prev;
            const next = { ...prev };
            delete next[dexId];
            return next;
        });
    }
function triggerXpFx(dexId, delta, dexType) {
        if (!delta)
            return;
        setXpFx({ dexId, delta, color: dexTypeColor(dexType), nonce: Date.now() + Math.random() });
        setBumpFx({ dexId, nonce: Date.now() + Math.random() });
        markRecent(dexId);
        if (delta > 0)
            Sound.play("xpUp");
        else
            Sound.play("xpDown");
    }
    function triggerLevelUpFx(dexId) {
        setLvlFx({ dexId, nonce: Date.now() + Math.random() });
        Sound.play("levelUp");
    }
    function pushToast(msg){
        const now = Date.now();
        // De-dupe identical messages within 2s
        const key = msg;
        const last = lastToastRef.current[key] || 0;
        if (now - last < 2000) return;
        lastToastRef.current[key] = now;
        const id = now + Math.random();
        setToasts(prev => [...prev, { id, text: msg }].slice(-3));
        setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 1800);
    }
    function triggerPulse(which) {
        const n = Date.now();
        if (which === "capture")
            setPulseFx(p => ({ ...p, capture: n }));
        if (which === "journal")
            setPulseFx(p => ({ ...p, journal: n }));
        Sound.play("save");
    }
    const [state, setState] = React.useState(() => {
        const loaded = loadState();
        if (loaded) {
            return { dexes: loaded.dexes, timeline: loaded.timeline, history: [], version: loaded.version };
        }
        const seeded = defaultSeed();
        return { dexes: seeded.dexes, timeline: seeded.timeline, history: [], version: seeded.version };
    });
    React.useEffect(() => {
        saveState({ version: state.version || SCHEMA_VERSION, dexes: state.dexes, timeline: state.timeline });
    }, [state.dexes, state.timeline, state.version]);

    // ---- Phase 3 observers (do NOT modify core XP/timeline logic) ----
    React.useEffect(() => {
        // Reset session today bucket on day change
        const dayKey = localDayKey(Date.now());
        if (sessionDayRef.current !== dayKey) {
            sessionDayRef.current = dayKey;
            setSessionTodayXP(0);
        }

        // Detect total XP deltas (captures quick +10/-5 that don't write timeline)
        const total = totalXPFromDexes(state.dexes);
        if (prevTotalRef.current === null) {
            prevTotalRef.current = total;
        } else {
            const delta = total - prevTotalRef.current;
            if (delta !== 0) {
                setSessionTodayXP(v => v + delta);
                // Milestone toasts
                const milestones = [100, 250, 500, 1000, 2000, 5000, 10000];
                for (const ms of milestones) {
                    if (prevTotalRef.current < ms && total >= ms) pushToast(`Milestone: ${ms} total XP`);
                }
                prevTotalRef.current = total;
            }
        }

        // Level-up toasts (compare level indexes per dex)
        const prevLv = prevLevelsRef.current || {};
        const nextLv = {};
        for (const d of state.dexes) {
            const idx = levelIndexFromXP(d.xp);
            nextLv[d.id] = idx;
            const before = prevLv[d.id];
            if (before !== undefined && idx > before) {
                pushToast(`Level up: ${d.name} â†’ ${LEVELS[idx]}`);
            }
        }
        prevLevelsRef.current = nextLv;

        // Streak milestone toasts (timeline days + session activity today)
        const days = daySetFromTimeline(state.timeline);
        if (sessionTodayXP !== 0) days.add(localDayKey(Date.now()));
        const streak = computeStreakDaysFromDaySet(days);
        const prevStreak = safeNumber(lastToastRef.current.__streakSeen, 0);
        if (streak !== prevStreak) lastToastRef.current.__streakSeen = streak;
        const streakMilestones = [3, 7, 14, 30, 60, 100];
        for (const sm of streakMilestones) {
            if (prevStreak < sm && streak >= sm) pushToast(`Streak: ${sm} days`);
        }
    }, [state.dexes, state.timeline]);

    React.useEffect(() => {
        if (screen === "details" || screen === "journal") {
            const exists = state.dexes.some(d => d.id === active);
            if (!exists) {
                setScreen("home");
                setActive(null);
            }
        }
    }, [screen, active, state.dexes]);
    function pushHistory(prev) {
        const snap = deepClone({
            version: prev.version || SCHEMA_VERSION,
            dexes: prev.dexes,
            timeline: prev.timeline
        });
        return [...prev.history, snap].slice(-MAX_HISTORY);
    }
    function commit(mutator) {
        setState(prev => {
            const draft = deepClone({
                version: prev.version || SCHEMA_VERSION,
                dexes: prev.dexes,
                timeline: prev.timeline
            });
            mutator(draft);
            const repaired = repairState(draft);
            return {
                version: repaired.version || prev.version || SCHEMA_VERSION,
                dexes: repaired.dexes,
                timeline: repaired.timeline,
                history: pushHistory(prev)
            };
        });
    }
    function undo() {
        setState(s => {
            if (!s.history.length)
                return s;
            const last = s.history[s.history.length - 1];
            const repaired = repairState(last);
            Sound.play("undo");
            return {
                version: repaired.version || s.version || SCHEMA_VERSION,
                dexes: deepClone(repaired.dexes),
                timeline: deepClone(repaired.timeline),
                history: s.history.slice(0, -1)
            };
        });
    }
    // ---- Core actions ----
    function addXP(dexId, amt, text = "", entryType = "xp") {
        const dNow = state.dexes.find(x => x.id === dexId);
        if (dNow) {
            const before = safeNumber(dNow.xp, 0);
            const after = Math.max(0, before + safeNumber(amt, 0));
            const delta = after - before;
            triggerXpFx(dexId, delta, dNow.type);
            const beforeLvl = levelIndexFromXP(before);
            const afterLvl = levelIndexFromXP(after);
            if (afterLvl > beforeLvl)
                triggerLevelUpFx(dexId);
        }
        commit(draft => {
            const d = draft.dexes.find(x => x.id === dexId);
            if (!d)
                return;
            const before = safeNumber(d.xp, 0);
            const after = Math.max(0, before + safeNumber(amt, 0));
            const delta = after - before;
            d.xp = after;
            if (text && safeString(text).trim().length) {
                const entry = {
                    text: safeString(text).trim(),
                    xp: delta,
                    entryType: validEntryType(entryType),
                    ts: Date.now()
                };
                d.log = Array.isArray(d.log) ? d.log : [];
                d.log.push(entry);
                draft.timeline.unshift({
                    dexId: d.id,
                    dex: d.name,
                    dexType: d.type,
                    entryType: entry.entryType,
                    xp: entry.xp,
                    text: entry.text,
                    ts: entry.ts
                });
            }
        });
    }
    function resetDex(dexId) {
        commit(draft => {
            const d = draft.dexes.find(x => x.id === dexId);
            if (!d)
                return;
            d.xp = 0;
            d.log = [];
        });
        markRecent(dexId);
        Sound.play("reset");
    }
    function deleteDex(dexId) {
        commit(draft => {
            draft.dexes = draft.dexes.filter(d => d.id !== dexId);
        });
        clearRecent(dexId);
        setActive(null);
        setScreen("home");
        Sound.play("delete");
    }
    function resetAll() {
        try {
            localStorage.removeItem(STORAGE_KEY);
        }
        catch (e) { }
        const seeded = defaultSeed();
        setState({ dexes: seeded.dexes, timeline: seeded.timeline, history: [], version: seeded.version });
        setActive(null);
        setScreen("home");
        Sound.play("resetAll");
    }
    // ----- Create/Edit Dex -----
    function openCreateDex() {
        setFormMode("create");
        setFormId(null);
        setFormName("");
        setFormType("Skill");
        setScreen("dexForm");
        Sound.play("open");
    }
    function openEditDex(d) {
        setFormMode("edit");
        setFormId(d.id);
        setFormName(d.name);
        setFormType(d.type);
        setScreen("dexForm");
        Sound.play("open");
    }
    function saveDex() {
        const name = safeString(formName).trim();
        const type = validDexType(formType) ? formType : "Skill";
        if (!name)
            return;
        commit(draft => {
            if (formMode === "create") {
                draft.dexes.push({ id: safeUUID(), name, type, xp: 0, log: [] });
            }
            else {
                const d = draft.dexes.find(x => x.id === formId);
                if (d) {
                    d.name = name;
                    d.type = type;
                }
            }
        });
        setScreen("home");
        Sound.play("saveDex");
    }
    // ----- Export/Import actions -----
    function exportSave() {
        const payload = repairState({ version: state.version || SCHEMA_VERSION, dexes: state.dexes, timeline: state.timeline });
        payload.version = SCHEMA_VERSION;
        downloadJSON("lifedex-save.json", payload);
        Sound.play("export");
    }
    async function importSaveFromFile(file) {
        try {
            const txt = await readFileAsText(file);
            const parsed = JSON.parse(txt);
            const migrated = migrateState(parsed);
            if (!migrated)
                throw new Error("Invalid save file");
            const repaired = repairState({ version: SCHEMA_VERSION, dexes: migrated.dexes, timeline: migrated.timeline });
            repaired.version = SCHEMA_VERSION;
            setState({ dexes: repaired.dexes, timeline: repaired.timeline, history: [], version: repaired.version });
            setActive(null);
            setScreen("home");
            saveState(repaired);
            alert("Import successful.");
            Sound.play("import");
        }
        catch (e) {
            alert("Import failed. Make sure it's a valid lifedex-save.json file.");
        }
    }
    // ------------------- SCREENS -------------------
    if (screen === "dexForm") {
        return (React.createElement(React.Fragment, null,
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement(ToastLayer, { toasts: toasts }),
            React.createElement("button", { className: "back", onClick: () => setScreen("home") }, "Back"),
            React.createElement("div", { className: "card" },
                React.createElement("h2", null, formMode === "create" ? "Create Dex" : "Edit Dex"),
                React.createElement("div", { className: "muted" }, "XP is preserved when editing."),
                React.createElement("input", { value: formName, onChange: e => setFormName(e.target.value), placeholder: "Dex name (e.g., Gym, Coding, Cooking)" }),
                React.createElement("select", { value: formType, onChange: e => setFormType(e.target.value) },
                    React.createElement("option", null, "Skill"),
                    React.createElement("option", null, "Career"),
                    React.createElement("option", null, "Trait"),
                    React.createElement("option", null, "Hobby")),
                React.createElement("div", { className: "row", style: { marginTop: 10 } },
                    React.createElement("button", { className: "btn", onClick: saveDex }, "Save"),
                    React.createElement("button", { className: "btn2", onClick: () => setScreen("home") }, "Cancel")),
                React.createElement("div", { className: "smallNote" }, "Tip: Choose the type so Timeline filters work properly."))));
    }
    if (screen === "details") {
        const d = state.dexes.find(x => x.id === active);
        if (!d)
            return null;
        const lvl = levelFromXP(d.xp);
        const pct = progressPercent(d.xp);
        const showXp = xpFx.dexId === d.id;
        const showLvl = lvlFx.dexId === d.id;
        const fillClass = (bumpFx.dexId === d.id) ? "fill bump" : "fill";
        const nextInfo = xpToNextLevelInfo(d.xp);
        return (React.createElement(React.Fragment, null,
            React.createElement("button", { className: "back", onClick: () => setScreen("home") }, "Back"),
            React.createElement("div", { className: "card" },
                React.createElement("div", { className: `banner ${d.type.toLowerCase()} ${showLvl ? "levelUpGlow" : ""}` },
                    React.createElement("h1", null, d.name),
                    React.createElement("div", { className: "muted" },
                        d.type,
                        " \u2022 ",
                        lvl,
                        " \u2022 ",
                        d.xp,
                        " XP"),
                    React.createElement("div", { className: "smallNote" }, nextInfo.done ? "Max level reached" : `${nextInfo.remaining} XP to ${nextInfo.next}`),
                    React.createElement("div", { className: "bar" },
                        React.createElement("div", { className: fillClass, style: { width: pct + "%" } })),
                    showXp && React.createElement(XPFloat, { delta: xpFx.delta, color: xpFx.color, nonce: xpFx.nonce })),
                React.createElement("div", { className: "row" },
                    React.createElement("button", { className: "btn", onClick: () => addXP(d.id, 10) }, "+10 XP"),
                    React.createElement("button", { className: "btn2", onClick: () => addXP(d.id, -5) }, "-5 XP"),
                    React.createElement("button", { className: "btn2", onClick: undo }, "Undo"),
                    React.createElement("button", { className: "btn2", onClick: () => { setFilter("All"); setScreen("timeline"); } }, "Timeline")),
                React.createElement("div", { className: "smallNote" }, "Capture and Journal entries add XP and appear in Timeline.")),
            React.createElement("div", { className: `card ${pulseFx.capture ? "savePulse" : ""}`, key: pulseFx.capture ? ("cap_" + pulseFx.capture) : "cap" },
                React.createElement("b", null, "Capture moment"),
                React.createElement("textarea", { placeholder: "Type and press Enter to save...", onKeyDown: (e) => {
                        if (e.key === "Enter" && !e.shiftKey) {
                            e.preventDefault();
                            const val = e.currentTarget.value;
                            if (val.trim()) {
                                addXP(d.id, 5, val, "capture");
                                e.currentTarget.value = "";
                                triggerPulse("capture");
                            }
                        }
                    } }),
                React.createElement("div", { className: "smallNote" }, "Enter saves. Shift+Enter makes a new line.")),
            React.createElement("div", { className: "card row" },
                React.createElement("button", { className: "btn2", onClick: () => openEditDex(d) }, "Edit Dex"),
                React.createElement("button", { className: "btnDanger", onClick: () => resetDex(d.id) }, "Reset"),
                React.createElement("button", { className: "btnDanger", onClick: () => deleteDex(d.id) }, "Delete")),
            React.createElement("div", { className: "card" },
                React.createElement("b", null, "Entries"),
                (d.log || []).length === 0 && React.createElement("div", { className: "smallNote" }, "No entries yet."),
                (d.log || []).slice().reverse().map((l, i) => (React.createElement("div", { key: i, className: "logItem" },
                    React.createElement("b", null, l.entryType),
                    " ",
                    l.xp >= 0 ? `+${l.xp}` : l.xp,
                    " XP",
                    React.createElement("div", null, l.text)))))));
    }
    if (screen === "journal") {
        const d = state.dexes.find(x => x.id === active);
        if (!d)
            return null;
        return (React.createElement(React.Fragment, null,
            React.createElement("button", { className: "back", onClick: () => setScreen("home") }, "Back"),
            React.createElement("div", { className: "card" },
                React.createElement("div", { className: `banner ${d.type.toLowerCase()}` },
                    React.createElement("h2", null, d.name),
                    React.createElement("div", { className: "muted" },
                        "Journal \u2022 ",
                        d.type)),
                React.createElement("textarea", { value: journal, onChange: e => setJournal(e.target.value), placeholder: "Write your journal entry..." }),
                React.createElement("div", { className: "row", style: { marginTop: 10 } },
                    React.createElement("button", { className: "btn", onClick: () => {
                            if (!journal.trim())
                                return;
                            addXP(d.id, 5, journal, "journal");
                            setJournal("");
                            setFilter("All");
                            setScreen("timeline");
                            triggerPulse("journal");
                        } }, "Save Journal (+5 XP)"),
                    React.createElement("button", { className: "btn2", onClick: undo }, "Undo")),
                React.createElement("div", { className: "smallNote" }, "Journal saves to Timeline under the correct Dex type.")),
            React.createElement("div", { className: `card ${pulseFx.journal ? "savePulse" : ""}`, key: pulseFx.journal ? ("jr_" + pulseFx.journal) : "jr" },
                React.createElement("b", null, "Saved feedback"),
                React.createElement("div", { className: "smallNote" }, "When you save a journal entry, this card pulses to confirm it worked."))));
    }
    if (screen === "timeline") {
        const items = state.timeline.filter(t => filter === "All" || t.dexType === filter);
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: "pillRow" }, ["All", "Skill", "Career", "Trait", "Hobby"].map(t => (React.createElement("div", { key: t, className: `pill ${filter === t ? "active" : ""}`, onClick: () => setFilter(t) }, t)))),
            React.createElement("button", { className: "back", onClick: () => setScreen("home") }, "Back"),
            React.createElement("div", { className: "card" },
                React.createElement("div", { className: "row", style: { justifyContent: "space-between" } },
                    React.createElement("b", null, "Timeline"),
                    React.createElement("button", { className: "btn2", onClick: undo }, "Undo")),
                React.createElement("div", { className: "smallNote" }, "Filter is by Dex type (Skill/Career/Trait/Hobby).")),
            items.length === 0 && (React.createElement("div", { className: "card" },
                React.createElement("b", null, "No entries yet."),
                React.createElement("div", { className: "smallNote" }, "Add a Capture or Journal entry to populate Timeline."))),
            items.map((t, i) => (React.createElement("div", { key: i, className: `card ${String(t.dexType || "Skill").toLowerCase()}` },
                React.createElement("b", null, t.dex),
                " \u2022 ",
                t.dexType,
                " \u2022 ",
                t.entryType,
                " \u2022 ",
                t.xp >= 0 ? `+${t.xp}` : t.xp,
                " XP",
                React.createElement("div", { style: { marginTop: 6 } }, t.text))))));
    }
    // HOME
    const todayXP = computeTodayXP(state.timeline) + sessionTodayXP;
    const todayLabel = todayXP >= 0 ? `+${todayXP}` : `${todayXP}`;
    const _days = daySetFromTimeline(state.timeline);
    if (sessionTodayXP !== 0) _days.add(localDayKey(Date.now()));
    const streakDays = computeStreakDaysFromDaySet(_days);

    return (React.createElement(React.Fragment, null,
        React.createElement("h1", null, "LifeDex"),
        React.createElement("div", { className: "todayLine" },
            React.createElement("div", { className: "muted" }, "Your life, indexed."),
            React.createElement("div", { style: { display: "flex", gap: 8, alignItems: "center" } },
                React.createElement("div", { className: "todayPill", title: "Net XP earned today (based on timeline timestamps + in-session XP changes)" },
                    "Today: ",
                    React.createElement("b", { style: { color: todayXP >= 0 ? "#22c55e" : "#fb7185" } },
                        todayLabel,
                        " XP")),
                React.createElement("div", { className: "streakPill", title: "Consecutive days with activity (timeline + in-session XP today)" },
                    "Streak: ",
                    React.createElement("b", null, streakDays),
                    " day",
                    streakDays === 1 ? "" : "s"))),
        React.createElement("div", { className: "card row" },
            React.createElement("button", { className: "btn", onClick: openCreateDex }, "+ New Dex"),
            React.createElement("button", { className: "btn2", onClick: () => { setFilter("All"); setScreen("timeline"); } }, "Timeline"),
            React.createElement("button", { className: "btn2", onClick: undo }, "Undo"),
            React.createElement("button", { className: "btnDanger", onClick: resetAll }, "Reset All")),
        React.createElement("div", { className: "card" },
            React.createElement("b", null, "Data"),
            React.createElement("div", { className: "muted" }, "Export a backup file or import one to restore/transfer your LifeDex."),
            React.createElement("div", { className: "row", style: { marginTop: 10 } },
                React.createElement("button", { className: "btn2", onClick: exportSave }, "Export Save"),
                React.createElement("button", { className: "btn2", onClick: () => { var _a; return (_a = importRef.current) === null || _a === void 0 ? void 0 : _a.click(); } }, "Import Save"),
                React.createElement("input", { ref: importRef, type: "file", accept: "application/json", style: { display: "none" }, onChange: async (e) => {
                        var _a;
                        const file = (_a = e.target.files) === null || _a === void 0 ? void 0 : _a[0];
                        e.target.value = "";
                        if (!file)
                            return;
                        await importSaveFromFile(file);
                    } })),
            React.createElement("div", { className: "smallNote" }, "Tip: Export before big changes so you can restore instantly.")),
        state.dexes.map(d => {
            const lvl = levelFromXP(d.xp);
            const pct = progressPercent(d.xp);
            const nextInfo = xpToNextLevelInfo(d.xp);
            const recent = isRecent(d.id); // uses tick implicitly via rerender
            return (React.createElement("div", { key: d.id, className: `card ${recent ? "recentGlow" : ""}`, onClick: () => { } },
                React.createElement("div", { className: `banner ${d.type.toLowerCase()}` },
                    React.createElement("h2", null, d.name),
                    React.createElement("div", { className: "muted" },
                        d.type,
                        " \u2022 ",
                        lvl,
                        " \u2022 ",
                        d.xp,
                        " XP"),
                    React.createElement("div", { className: "smallNote" }, nextInfo.done ? "Max level reached" : `${nextInfo.remaining} XP to ${nextInfo.next}`),
                    React.createElement("div", { className: "bar" },
                        React.createElement("div", { className: "fill", style: { width: pct + "%" } }))),
                React.createElement("div", { className: "row" },
                    React.createElement("button", { className: "btn", onClick: () => {
                            clearRecent(d.id);
                            setActive(d.id);
                            setScreen("details");
                        } }, "Details"),
                    React.createElement("button", { className: "btn2", onClick: () => {
                            clearRecent(d.id);
                            setActive(d.id);
                            setScreen("journal");
                        } }, "Journal"),
                    React.createElement("button", { className: "btn2", onClick: () => openEditDex(d) }, "Edit"),
                    React.createElement("button", { className: "btn2", onClick: () => { setFilter("All"); setScreen("timeline"); } }, "Timeline"))));
        })));
}
ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App, null));

</script>

</body>
</html>
